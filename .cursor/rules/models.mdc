---
alwaysApply: true
---

# Django Model Development Rules

## Model Structure

### Base Model Inheritance
```python
from core.base_models import TimeStampedModel

class MyModel(TimeStampedModel):
    """Model description."""
    
    # Fields here
    
    class Meta:
        db_table = 'my_model_table'
        ordering = ['-created_at']
        verbose_name = 'My Model'
        verbose_name_plural = 'My Models'
```

### Field Definitions
- Use descriptive field names
- Include help_text for all fields
- Use appropriate validators
- Set default values where appropriate
- Use choices for constrained string fields

```python
name = models.CharField(
    max_length=100,
    help_text="Descriptive name for the model"
)

status = models.CharField(
    max_length=20,
    choices=[
        ('active', 'Active'),
        ('inactive', 'Inactive'),
        ('pending', 'Pending'),
    ],
    default='active',
    help_text="Current status of the model"
)

price = models.DecimalField(
    max_digits=10,
    decimal_places=2,
    validators=[MinValueValidator(Decimal('0.00'))],
    help_text="Price in USD"
)
```

## Relationships

### ForeignKey
```python
user = models.ForeignKey(
    settings.AUTH_USER_MODEL,
    on_delete=models.CASCADE,
    related_name='my_models',
    help_text="User who owns this model"
)
```

### ManyToManyField
```python
tags = models.ManyToManyField(
    'Tag',
    related_name='my_models',
    blank=True,
    help_text="Tags associated with this model"
)
```

### OneToOneField
```python
profile = models.OneToOneField(
    'Profile',
    on_delete=models.CASCADE,
    related_name='my_model',
    help_text="Associated profile"
)
```

## Model Methods

### String Representation
```python
def __str__(self):
    return f"{self.name} - {self.user.username}"
```

### Save Method Override
```python
def save(self, *args, **kwargs):
    """Override save to add logging and business logic."""
    is_new = self.pk is None
    
    if is_new:
        log_info(
            "Creating new model",
            model_type=self.__class__.__name__,
            user_id=getattr(self, 'user_id', None)
        )
    else:
        log_info(
            "Updating model",
            model_id=self.pk,
            user_id=getattr(self, 'user_id', None)
        )
    
    super().save(*args, **kwargs)
```

### Properties
```python
@property
def full_name(self):
    """Get full name."""
    return f"{self.first_name} {self.last_name}".strip()

@property
def is_active(self):
    """Check if model is active."""
    return self.status == 'active'

@property
def age(self):
    """Calculate age from date of birth."""
    if self.date_of_birth:
        from datetime import date
        today = date.today()
        return today.year - self.date_of_birth.year - (
            (today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day)
        )
    return None
```

### Business Logic Methods
```python
def activate(self):
    """Activate the model."""
    self.status = 'active'
    self.save()
    
    log_info(
        "Model activated",
        model_id=self.pk,
        user_id=getattr(self, 'user_id', None)
    )

def deactivate(self):
    """Deactivate the model."""
    self.status = 'inactive'
    self.save()
    
    log_info(
        "Model deactivated",
        model_id=self.pk,
        user_id=getattr(self, 'user_id', None)
    )
```

## Field Types

### CharField
```python
name = models.CharField(
    max_length=100,
    help_text="Name of the item"
)

slug = models.SlugField(
    unique=True,
    help_text="URL-friendly identifier"
)

description = models.TextField(
    blank=True,
    help_text="Detailed description"
)
```

### Numeric Fields
```python
count = models.IntegerField(
    default=0,
    validators=[MinValueValidator(0)],
    help_text="Count of items"
)

price = models.DecimalField(
    max_digits=10,
    decimal_places=2,
    validators=[MinValueValidator(Decimal('0.00'))],
    help_text="Price in USD"
)

percentage = models.FloatField(
    validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
    help_text="Percentage value"
)
```

### Date/Time Fields
```python
created_at = models.DateTimeField(auto_now_add=True)
updated_at = models.DateTimeField(auto_now=True)

start_date = models.DateField(help_text="Start date")
end_date = models.DateField(
    null=True,
    blank=True,
    help_text="End date (optional)"
)

timestamp = models.DateTimeField(help_text="Specific timestamp")
```

### Boolean Fields
```python
is_active = models.BooleanField(
    default=True,
    help_text="Whether this item is active"
)

is_featured = models.BooleanField(
    default=False,
    help_text="Whether this item is featured"
)
```

### JSON Fields
```python
metadata = models.JSONField(
    default=dict,
    blank=True,
    help_text="Additional metadata"
)

settings = models.JSONField(
    default=dict,
    help_text="User settings"
)
```

## Validation

### Field Validators
```python
from django.core.validators import MinValueValidator, MaxValueValidator, RegexValidator

age = models.IntegerField(
    validators=[
        MinValueValidator(0, "Age cannot be negative"),
        MaxValueValidator(150, "Age cannot exceed 150")
    ],
    help_text="Age in years"
)

phone = models.CharField(
    max_length=15,
    validators=[
        RegexValidator(
            regex=r'^\+?1?\d{9,15}$',
            message="Phone number must be entered in the format: '+999999999'. Up to 15 digits allowed."
        )
    ],
    help_text="Phone number"
)
```

### Model Validation
```python
def clean(self):
    """Custom model validation."""
    super().clean()
    
    if self.start_date and self.end_date:
        if self.start_date > self.end_date:
            raise ValidationError("Start date cannot be after end date")
    
    if self.price < 0:
        raise ValidationError("Price cannot be negative")
```

## Meta Options

### Basic Meta
```python
class Meta:
    db_table = 'my_model_table'
    ordering = ['-created_at']
    verbose_name = 'My Model'
    verbose_name_plural = 'My Models'
```

### Advanced Meta
```python
class Meta:
    db_table = 'my_model_table'
    ordering = ['-created_at']
    verbose_name = 'My Model'
    verbose_name_plural = 'My Models'
    unique_together = ['field1', 'field2']
    indexes = [
        models.Index(fields=['status', 'created_at']),
        models.Index(fields=['user', 'status']),
    ]
    constraints = [
        models.CheckConstraint(
            check=models.Q(price__gte=0),
            name='positive_price'
        ),
    ]
```

## Manager Methods

### Custom Manager
```python
class MyModelManager(models.Manager):
    def active(self):
        """Get active models."""
        return self.filter(status='active')
    
    def for_user(self, user):
        """Get models for a specific user."""
        return self.filter(user=user)
    
    def recent(self, days=7):
        """Get models created in the last N days."""
        from django.utils import timezone
        from datetime import timedelta
        
        cutoff_date = timezone.now() - timedelta(days=days)
        return self.filter(created_at__gte=cutoff_date)

class MyModel(TimeStampedModel):
    # fields...
    
    objects = MyModelManager()
```

## Best Practices

1. **Always inherit from TimeStampedModel for created_at/updated_at**
2. **Use descriptive field names and help_text**
3. **Include appropriate validators**
4. **Use choices for constrained string fields**
5. **Override save() method for logging and business logic**
6. **Use properties for computed fields**
7. **Include proper Meta options**
8. **Use related_name for relationships**
9. **Include proper string representation**
10. **Use custom managers for common queries**
11. **Include proper validation methods**
12. **Use appropriate field types and constraints**
13. **Include proper indexes for performance**
14. **Use JSON fields for flexible data**
15. **Include proper error handling in methods**
description:
globs:
alwaysApply: false
---
